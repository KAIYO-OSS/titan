{"values": [{"isRequired": "true", "name": "global.imagePullSecrets", "value": "[] (does not add image pull secrets to deployed pods)", "description": "Global Docker registry secret names as an array"}, {"isRequired": "false", "name": "global.imageRegistry", "value": "nil", "description": "Global Docker Image registry"}, {"isRequired": "false", "name": "global.postgresql.postgresqlDatabase", "value": "nil", "description": "PostgreSQL database (overrides postgresqlDatabase)"}, {"isRequired": "false", "name": "global.postgresql.postgresqlUsername", "value": "nil", "description": "PostgreSQL username (overrides postgresqlUsername)"}, {"isRequired": "false", "name": "global.postgresql.existingSecret", "value": "nil", "description": "Name of existing secret to use for PostgreSQL passwords (overrides existingSecret)"}, {"isRequired": "false", "name": "global.postgresql.postgresqlPassword", "value": "nil", "description": "PostgreSQL admin password (overrides postgresqlPassword)"}, {"isRequired": "false", "name": "global.postgresql.servicePort", "value": "nil", "description": "PostgreSQL port (overrides service.port)"}, {"isRequired": "false", "name": "global.postgresql.replicationPassword", "value": "nil", "description": "Replication user password (overrides replication.password)"}, {"isRequired": "false", "name": "global.storageClass", "value": "nil", "description": "Global storage class for dynamic provisioning"}, {"isRequired": "true", "name": "image.registry", "value": "docker.io", "description": "PostgreSQL Image registry"}, {"isRequired": "true", "name": "image.repository", "value": "bitnami/postgresql", "description": "PostgreSQL Image name"}, {"isRequired": "true", "name": "image.tag", "value": "{TAG_NAME}", "description": "PostgreSQL Image tag"}, {"isRequired": "true", "name": "image.pullPolicy", "value": "IfNotPresent", "description": "PostgreSQL Image pull policy"}, {"isRequired": "false", "name": "image.pullSecrets", "value": "nil (does not add image pull secrets to deployed pods)", "description": "Specify Image pull secrets"}, {"isRequired": "true", "name": "image.debug", "value": "false", "description": "Specify if debug values should be set"}, {"isRequired": "false", "name": "nameOverride", "value": "nil", "description": "String to partially override postgresql.fullname template with a string (will prepend the release name)"}, {"isRequired": "false", "name": "fullnameOverride", "value": "nil", "description": "String to fully override postgresql.fullname template with a string"}, {"isRequired": "true", "name": "volumePermissions.enabled", "value": "false", "description": "Enable init container that changes volume permissions in the data directory (for cases where the default k8s runAsUser and fsUser values do not work)"}, {"isRequired": "true", "name": "volumePermissions.image.registry", "value": "docker.io", "description": "Init container volume-permissions image registry"}, {"isRequired": "true", "name": "volumePermissions.image.repository", "value": "bitnami/minideb", "description": "Init container volume-permissions image name"}, {"isRequired": "true", "name": "volumePermissions.image.tag", "value": "buster", "description": "Init container volume-permissions image tag"}, {"isRequired": "true", "name": "volumePermissions.image.pullPolicy", "value": "Always", "description": "Init container volume-permissions image pull policy"}, {"isRequired": "true", "name": "volumePermissions.securityContext.runAsUser", "value": "0", "description": "User ID for the init container (when facing issues in OpenShift or uid unknown, try value \"auto\")"}, {"isRequired": "true", "name": "usePasswordFile", "value": "false", "description": "Have the secrets mounted as a file instead of env vars"}, {"isRequired": "true", "name": "ldap.enabled", "value": "false", "description": "Enable LDAP support"}, {"isRequired": "false", "name": "ldap.existingSecret", "value": "nil", "description": "Name of existing secret to use for LDAP passwords"}, {"isRequired": "false", "name": "ldap.url", "value": "nil", "description": "LDAP URL beginning in the form ldap[s]://host[:port]/basedn[?[attribute][?[scope][?[filter]]]]"}, {"isRequired": "false", "name": "ldap.server", "value": "nil", "description": "IP address or name of the LDAP server."}, {"isRequired": "false", "name": "ldap.port", "value": "nil", "description": "Port number on the LDAP server to connect to"}, {"isRequired": "false", "name": "ldap.scheme", "value": "nil", "description": "Set to ldaps to use LDAPS."}, {"isRequired": "false", "name": "ldap.tls", "value": "nil", "description": "Set to 1 to use TLS encryption"}, {"isRequired": "false", "name": "ldap.prefix", "value": "nil", "description": "String to prepend to the user name when forming the DN to bind"}, {"isRequired": "false", "name": "ldap.suffix", "value": "nil", "description": "String to append to the user name when forming the DN to bind"}, {"isRequired": "false", "name": "ldap.search_attr", "value": "nil", "description": "Attribute to match agains the user name in the search"}, {"isRequired": "false", "name": "ldap.search_filter", "value": "nil", "description": "The search filter to use when doing search+bind authentication"}, {"isRequired": "false", "name": "ldap.baseDN", "value": "nil", "description": "Root DN to begin the search for the user in"}, {"isRequired": "false", "name": "ldap.bindDN", "value": "nil", "description": "DN of user to bind to LDAP"}, {"isRequired": "false", "name": "ldap.bind_password", "value": "nil", "description": "Password for the user to bind to LDAP"}, {"isRequired": "true", "name": "replication.enabled", "value": "false", "description": "Enable replication"}, {"isRequired": "true", "name": "replication.user", "value": "repl_user", "description": "Replication user"}, {"isRequired": "true", "name": "replication.password", "value": "repl_password", "description": "Replication user password"}, {"isRequired": "true", "name": "replication.slaveReplicas", "value": "1", "description": "Number of slaves replicas"}, {"isRequired": "true", "name": "replication.synchronousCommit", "value": "off", "description": "Set synchronous commit mode. Allowed values: on, remote_apply, remote_write, local and off"}, {"isRequired": "true", "name": "replication.numSynchronousReplicas", "value": "0", "description": "Number of replicas that will have synchronous replication. Note: Cannot be greater than replication.slaveReplicas."}, {"isRequired": "true", "name": "replication.applicationName", "value": "my_application", "description": "Cluster application name. Useful for advanced replication settings"}, {"isRequired": "false", "name": "existingSecret", "value": "nil", "description": "Name of existing secret to use for PostgreSQL passwords. The secret has to contain the keys postgresql-postgres-password which is the password for postgresqlUsername when it is different of postgres, postgresql-password which will override postgresqlPassword, postgresql-replication-password which will override replication.password and postgresql-ldap-password which will be sed to authenticate on LDAP. The value is evaluated as a template."}, {"isRequired": "true", "name": "postgresqlPostgresPassword", "value": "_random 10 character alphanumeric string_", "description": "PostgreSQL admin password (used when postgresqlUsername is not postgres, in which casepostgres is the admin username)."}, {"isRequired": "true", "name": "postgresqlUsername", "value": "postgres", "description": "PostgreSQL user (creates a non-admin user when postgresqlUsername is not postgres)"}, {"isRequired": "true", "name": "postgresqlPassword", "value": "_random 10 character alphanumeric string_", "description": "PostgreSQL user password"}, {"isRequired": "false", "name": "postgresqlDatabase", "value": "nil", "description": "PostgreSQL database"}, {"isRequired": "true", "name": "postgresqlDataDir", "value": "/bitnami/postgresql (same value as persistence.mountPath)", "description": "PostgreSQL data dir folder"}, {"isRequired": "true", "name": "extraEnv", "value": "[]", "description": "Any extra environment variables you would like to pass on to the pod. The value is evaluated as a template."}, {"isRequired": "false", "name": "extraEnvVarsCM", "value": "nil", "description": "Name of a Config Map containing extra environment variables you would like to pass on to the pod. The value is evaluated as a template."}, {"isRequired": "false", "name": "postgresqlInitdbArgs", "value": "nil", "description": "PostgreSQL initdb extra arguments"}, {"isRequired": "false", "name": "postgresqlInitdbWalDir", "value": "nil", "description": "PostgreSQL location for transaction log"}, {"isRequired": "false", "name": "postgresqlConfiguration", "value": "nil", "description": "Runtime Config Parameters"}, {"isRequired": "false", "name": "postgresqlExtendedConf", "value": "nil", "description": "Extended Runtime Config Parameters (appended to main or default configuration)"}, {"isRequired": "false", "name": "pgHbaConfiguration", "value": "nil (do not create pg_hba.conf)", "description": "Content of pg_hba.conf"}, {"isRequired": "false", "name": "configurationConfigMap", "value": "nil", "description": "ConfigMap with the PostgreSQL configuration files (Note: Overrides postgresqlConfiguration and pgHbaConfiguration). The value is evaluated as a template."}, {"isRequired": "false", "name": "extendedConfConfigMap", "value": "nil", "description": "ConfigMap with the extended PostgreSQL configuration files. The value is evaluated as a template."}, {"isRequired": "false", "name": "initdbScripts", "value": "nil", "description": "Dictionary of initdb scripts"}, {"isRequired": "false", "name": "initdbUser", "value": "nil", "description": "PostgreSQL user to execute the .sql and sql.gz scripts"}, {"isRequired": "false", "name": "initdbPassword", "value": "nil", "description": "Password for the user specified in initdbUser"}, {"isRequired": "false", "name": "initdbScriptsConfigMap", "value": "nil", "description": "ConfigMap with the initdb scripts (Note: Overrides initdbScripts). The value is evaluated as a template."}, {"isRequired": "false", "name": "initdbScriptsSecret", "value": "nil", "description": "Secret with initdb scripts that contain sensitive information (Note: can be used with initdbScriptsConfigMap or initdbScripts). The value is evaluated as a template."}, {"isRequired": "true", "name": "service.type", "value": "ClusterIP", "description": "Kubernetes Service type"}, {"isRequired": "true", "name": "service.port", "value": "5432", "description": "PostgreSQL port"}, {"isRequired": "false", "name": "service.nodePort", "value": "nil", "description": "Kubernetes Service nodePort"}, {"isRequired": "true", "name": "service.annotations", "value": "{} (evaluated as a template)", "description": "Annotations for PostgreSQL service"}, {"isRequired": "false", "name": "service.loadBalancerIP", "value": "nil", "description": "loadBalancerIP if service type is LoadBalancer"}, {"isRequired": "true", "name": "service.loadBalancerSourceRanges", "value": "[] (evaluated as a template)", "description": "Address that are allowed when svc is LoadBalancer"}, {"isRequired": "false", "name": "schedulerName", "value": "nil", "description": "Name of the k8s scheduler (other than default)"}, {"isRequired": "true", "name": "shmVolume.enabled", "value": "true", "description": "Enable emptyDir volume for /dev/shm for master and slave(s) Pod(s)"}, {"isRequired": "true", "name": "shmVolume.chmod.enabled", "value": "true", "description": "Run at init chmod 777 of the /dev/shm (ignored if volumePermissions.enabled is false)"}, {"isRequired": "true", "name": "persistence.enabled", "value": "true", "description": "Enable persistence using PVC"}, {"isRequired": "false", "name": "persistence.existingClaim", "value": "nil", "description": "Provide an existing PersistentVolumeClaim, the value is evaluated as a template."}, {"isRequired": "true", "name": "persistence.mountPath", "value": "/bitnami/postgresql", "description": "Path to mount the volume at"}, {"isRequired": "true", "name": "persistence.subPath", "value": "\"\"", "description": "Subdirectory of the volume to mount at"}, {"isRequired": "false", "name": "persistence.storageClass", "value": "nil", "description": "PVC Storage Class for PostgreSQL volume"}, {"isRequired": "true", "name": "persistence.accessModes", "value": "[ReadWriteOnce]", "description": "PVC Access Mode for PostgreSQL volume"}, {"isRequired": "true", "name": "persistence.size", "value": "8Gi", "description": "PVC Storage Request for PostgreSQL volume"}, {"isRequired": "true", "name": "persistence.annotations", "value": "{}", "description": "Annotations for the PVC"}, {"isRequired": "true", "name": "commonAnnotations", "value": "{}", "description": "Annotations to be added to all deployed resources (rendered as a template)"}, {"isRequired": "true", "name": "master.nodeSelector", "value": "{}", "description": "Node labels for pod assignment (postgresql master)"}, {"isRequired": "true", "name": "master.affinity", "value": "{}", "description": "Affinity labels for pod assignment (postgresql master)"}, {"isRequired": "true", "name": "master.tolerations", "value": "[]", "description": "Toleration labels for pod assignment (postgresql master)"}, {"isRequired": "true", "name": "master.anotations", "value": "{}", "description": "Map of annotations to add to the statefulset (postgresql master)"}, {"isRequired": "true", "name": "master.labels", "value": "{}", "description": "Map of labels to add to the statefulset (postgresql master)"}, {"isRequired": "true", "name": "master.podAnnotations", "value": "{}", "description": "Map of annotations to add to the pods (postgresql master)"}, {"isRequired": "true", "name": "master.podLabels", "value": "{}", "description": "Map of labels to add to the pods (postgresql master)"}, {"isRequired": "false", "name": "master.priorityClassName", "value": "nil", "description": "Priority Class to use for each pod (postgresql master)"}, {"isRequired": "true", "name": "master.extraInitContainers", "value": "[]", "description": "Additional init containers to add to the pods (postgresql master)"}, {"isRequired": "true", "name": "master.extraVolumeMounts", "value": "[]", "description": "Additional volume mounts to add to the pods (postgresql master)"}, {"isRequired": "true", "name": "master.extraVolumes", "value": "[]", "description": "Additional volumes to add to the pods (postgresql master)"}, {"isRequired": "true", "name": "master.sidecars", "value": "[]", "description": "Add additional containers to the pod"}, {"isRequired": "false", "name": "master.service.type", "value": "nil", "description": "Allows using a different service type for Master"}, {"isRequired": "false", "name": "master.service.nodePort", "value": "nil", "description": "Allows using a different nodePort for Master"}, {"isRequired": "false", "name": "master.service.clusterIP", "value": "nil", "description": "Allows using a different clusterIP for Master"}, {"isRequired": "true", "name": "slave.nodeSelector", "value": "{}", "description": "Node labels for pod assignment (postgresql slave)"}, {"isRequired": "true", "name": "slave.affinity", "value": "{}", "description": "Affinity labels for pod assignment (postgresql slave)"}, {"isRequired": "true", "name": "slave.tolerations", "value": "[]", "description": "Toleration labels for pod assignment (postgresql slave)"}, {"isRequired": "true", "name": "slave.anotations", "value": "{}", "description": "Map of annotations to add to the statefulsets (postgresql slave)"}, {"isRequired": "true", "name": "slave.labels", "value": "{}", "description": "Map of labels to add to the statefulsets (postgresql slave)"}, {"isRequired": "true", "name": "slave.podAnnotations", "value": "{}", "description": "Map of annotations to add to the pods (postgresql slave)"}, {"isRequired": "true", "name": "slave.podLabels", "value": "{}", "description": "Map of labels to add to the pods (postgresql slave)"}, {"isRequired": "false", "name": "slave.priorityClassName", "value": "nil", "description": "Priority Class to use for each pod (postgresql slave)"}, {"isRequired": "true", "name": "slave.extraInitContainers", "value": "[]", "description": "Additional init containers to add to the pods (postgresql slave)"}, {"isRequired": "true", "name": "slave.extraVolumeMounts", "value": "[]", "description": "Additional volume mounts to add to the pods (postgresql slave)"}, {"isRequired": "true", "name": "slave.extraVolumes", "value": "[]", "description": "Additional volumes to add to the pods (postgresql slave)"}, {"isRequired": "true", "name": "slave.sidecars", "value": "[]", "description": "Add additional containers to the pod"}, {"isRequired": "false", "name": "slave.service.type", "value": "nil", "description": "Allows using a different service type for Slave"}, {"isRequired": "false", "name": "slave.service.nodePort", "value": "nil", "description": "Allows using a different nodePort for Slave"}, {"isRequired": "false", "name": "slave.service.clusterIP", "value": "nil", "description": "Allows using a different clusterIP for Slave"}, {"isRequired": "false", "name": "terminationGracePeriodSeconds", "value": "nil", "description": "Seconds the pod needs to terminate gracefully"}, {"isRequired": "true", "name": "resources", "value": "Memory: 256Mi, CPU: 250m", "description": "CPU/Memory resource requests/limits"}, {"isRequired": "true", "name": "securityContext.enabled", "value": "true", "description": "Enable security context"}, {"isRequired": "true", "name": "securityContext.fsGroup", "value": "1001", "description": "Group ID for the container"}, {"isRequired": "true", "name": "securityContext.runAsUser", "value": "1001", "description": "User ID for the container"}, {"isRequired": "true", "name": "serviceAccount.enabled", "value": "false", "description": "Enable service account (Note: Service Account will only be automatically created if serviceAccount.name is not set)"}, {"isRequired": "false", "name": "serviceAccount.name", "value": "nil", "description": "Name of existing service account"}, {"isRequired": "true", "name": "livenessProbe.enabled", "value": "true", "description": "Would you like a livenessProbe to be enabled"}, {"isRequired": "true", "name": "networkPolicy.enabled", "value": "false", "description": "Enable NetworkPolicy"}, {"isRequired": "true", "name": "networkPolicy.allowExternal", "value": "true", "description": "Don't require client label for connections"}, {"isRequired": "true", "name": "networkPolicy.explicitNamespacesSelector", "value": "{}", "description": "A Kubernetes LabelSelector to explicitly select namespaces from which ingress traffic could be allowed"}, {"isRequired": "true", "name": "livenessProbe.initialDelaySeconds", "value": "30", "description": "Delay before liveness probe is initiated"}, {"isRequired": "true", "name": "livenessProbe.periodSeconds", "value": "10", "description": "How often to perform the probe"}, {"isRequired": "true", "name": "livenessProbe.timeoutSeconds", "value": "5", "description": "When the probe times out"}, {"isRequired": "true", "name": "livenessProbe.failureThreshold", "value": "6", "description": "Minimum consecutive failures for the probe to be considered failed after having succeeded."}, {"isRequired": "true", "name": "livenessProbe.successThreshold", "value": "1", "description": "Minimum consecutive successes for the probe to be considered successful after having failed"}, {"isRequired": "true", "name": "readinessProbe.enabled", "value": "true", "description": "would you like a readinessProbe to be enabled"}, {"isRequired": "true", "name": "readinessProbe.initialDelaySeconds", "value": "5", "description": "Delay before readiness probe is initiated"}, {"isRequired": "true", "name": "readinessProbe.periodSeconds", "value": "10", "description": "How often to perform the probe"}, {"isRequired": "true", "name": "readinessProbe.timeoutSeconds", "value": "5", "description": "When the probe times out"}, {"isRequired": "true", "name": "readinessProbe.failureThreshold", "value": "6", "description": "Minimum consecutive failures for the probe to be considered failed after having succeeded."}, {"isRequired": "true", "name": "readinessProbe.successThreshold", "value": "1", "description": "Minimum consecutive successes for the probe to be considered successful after having failed"}, {"isRequired": "true", "name": "tls.enabled", "value": "false", "description": "Enable TLS traffic support"}, {"isRequired": "true", "name": "tls.preferServerCiphers", "value": "true", "description": "Whether to use the server's TLS cipher preferences rather than the client's"}, {"isRequired": "false", "name": "tls.certificatesSecret", "value": "nil", "description": "Name of an existing secret that contains the certificates"}, {"isRequired": "true", "name": "tls.certFilename", "value": "\"\"", "description": "Certificate filename"}, {"isRequired": "true", "name": "tls.certKeyFilename", "value": "\"\"", "description": "Certificate key filename"}, {"isRequired": "false", "name": "tls.certCAFilename", "value": "nil", "description": "CA Certificate filename. If provided, PostgreSQL will authenticate TLS/SSL clients by requesting them a certificate."}, {"isRequired": "false", "name": "tls.crlFilename", "value": "nil", "description": "File containing a Certificate Revocation List"}, {"isRequired": "true", "name": "metrics.enabled", "value": "false", "description": "Start a prometheus exporter"}, {"isRequired": "true", "name": "metrics.service.type", "value": "ClusterIP", "description": "Kubernetes Service type"}, {"isRequired": "false", "name": "service.clusterIP", "value": "nil", "description": "Static clusterIP or None for headless services"}, {"isRequired": "true", "name": "metrics.service.annotations", "value": "{ prometheus.io/scrape: \"true\", prometheus.io/port: \"9187\"}", "description": "Additional annotations for metrics exporter pod"}, {"isRequired": "false", "name": "metrics.service.loadBalancerIP", "value": "nil", "description": "loadBalancerIP if redis metrics service type is LoadBalancer"}, {"isRequired": "true", "name": "metrics.serviceMonitor.enabled", "value": "false", "description": "Set this to true to create ServiceMonitor for Prometheus operator"}, {"isRequired": "true", "name": "metrics.serviceMonitor.additionalLabels", "value": "{}", "description": "Additional labels that can be used so ServiceMonitor will be discovered by Prometheus"}, {"isRequired": "false", "name": "metrics.serviceMonitor.namespace", "value": "nil", "description": "Optional namespace in which to create ServiceMonitor"}, {"isRequired": "false", "name": "metrics.serviceMonitor.interval", "value": "nil", "description": "Scrape interval. If not set, the Prometheus default scrape interval is used"}, {"isRequired": "false", "name": "metrics.serviceMonitor.scrapeTimeout", "value": "nil", "description": "Scrape timeout. If not set, the Prometheus default scrape timeout is used"}, {"isRequired": "true", "name": "metrics.prometheusRule.enabled", "value": "false", "description": "Set this to true to create prometheusRules for Prometheus operator"}, {"isRequired": "true", "name": "metrics.prometheusRule.additionalLabels", "value": "{}", "description": "Additional labels that can be used so prometheusRules will be discovered by Prometheus"}, {"isRequired": "true", "name": "metrics.prometheusRule.namespace", "value": "the same namespace as postgresql", "description": "namespace where prometheusRules resource should be created"}, {"isRequired": "true", "name": "metrics.prometheusRule.rules", "value": "[]", "description": "[rules](https://prometheus.io/docs/prometheus/latest/configuration/alerting_rules/) to be created, check values for an example."}, {"isRequired": "true", "name": "metrics.image.registry", "value": "docker.io", "description": "PostgreSQL Exporter Image registry"}, {"isRequired": "true", "name": "metrics.image.repository", "value": "bitnami/postgres-exporter", "description": "PostgreSQL Exporter Image name"}, {"isRequired": "true", "name": "metrics.image.tag", "value": "{TAG_NAME}", "description": "PostgreSQL Exporter Image tag"}, {"isRequired": "true", "name": "metrics.image.pullPolicy", "value": "IfNotPresent", "description": "PostgreSQL Exporter Image pull policy"}, {"isRequired": "false", "name": "metrics.image.pullSecrets", "value": "nil (does not add image pull secrets to deployed pods)", "description": "Specify Image pull secrets"}, {"isRequired": "false", "name": "metrics.customMetrics", "value": "nil", "description": "Additional custom metrics"}, {"isRequired": "true", "name": "metrics.extraEnvVars", "value": "{} (evaluated as a template)", "description": "Extra environment variables to add to exporter"}, {"isRequired": "true", "name": "metrics.securityContext.enabled", "value": "false", "description": "Enable security context for metrics"}, {"isRequired": "true", "name": "metrics.securityContext.runAsUser", "value": "1001", "description": "User ID for the container for metrics"}, {"isRequired": "true", "name": "metrics.livenessProbe.initialDelaySeconds", "value": "30", "description": "Delay before liveness probe is initiated"}, {"isRequired": "true", "name": "metrics.livenessProbe.periodSeconds", "value": "10", "description": "How often to perform the probe"}, {"isRequired": "true", "name": "metrics.livenessProbe.timeoutSeconds", "value": "5", "description": "When the probe times out"}, {"isRequired": "true", "name": "metrics.livenessProbe.failureThreshold", "value": "6", "description": "Minimum consecutive failures for the probe to be considered failed after having succeeded."}, {"isRequired": "true", "name": "metrics.livenessProbe.successThreshold", "value": "1", "description": "Minimum consecutive successes for the probe to be considered successful after having failed"}, {"isRequired": "true", "name": "metrics.readinessProbe.enabled", "value": "true", "description": "would you like a readinessProbe to be enabled"}, {"isRequired": "true", "name": "metrics.readinessProbe.initialDelaySeconds", "value": "5", "description": "Delay before liveness probe is initiated"}, {"isRequired": "true", "name": "metrics.readinessProbe.periodSeconds", "value": "10", "description": "How often to perform the probe"}, {"isRequired": "true", "name": "metrics.readinessProbe.timeoutSeconds", "value": "5", "description": "When the probe times out"}, {"isRequired": "true", "name": "metrics.readinessProbe.failureThreshold", "value": "6", "description": "Minimum consecutive failures for the probe to be considered failed after having succeeded."}, {"isRequired": "true", "name": "metrics.readinessProbe.successThreshold", "value": "1", "description": "Minimum consecutive successes for the probe to be considered successful after having failed"}, {"isRequired": "true", "name": "updateStrategy", "value": "{type: \"RollingUpdate\"}", "description": "Update strategy policy"}, {"isRequired": "true", "name": "psp.create", "value": "false", "description": "Create Pod Security Policy"}, {"isRequired": "true", "name": "rbac.create", "value": "false", "description": "Create Role and RoleBinding (required for PSP to work)"}]}